import { mkdir, writeFile } from 'fs/promises';
import { join } from 'path';
import type { GraphSpec, CandidateManifest } from '../../forge-core/src/types.js';
import { manifestHash } from '../../forge-core/src/manifest.js';

/**
 * Realize a graph specification into code
 */
export async function realizeGraph(
  graph: GraphSpec,
  outDir: string,
  manifest: CandidateManifest
): Promise<{ outDir: string; manifestPath: string }> {
  console.log(`Realizing graph to: ${outDir}`);

  // Create directory structure
  await mkdir(outDir, { recursive: true });
  await mkdir(join(outDir, 'src'), { recursive: true });
  await mkdir(join(outDir, 'tests'), { recursive: true });
  await mkdir(join(outDir, 'contracts'), { recursive: true });

  // Generate package.json
  await generatePackageJson(outDir, graph);

  // Generate source files
  await generateSourceFiles(outDir, graph);

  // Generate tests
  await generateTests(outDir, graph);

  // Write manifest
  const manifestPath = join(outDir, 'manifest.json');
  await writeFile(manifestPath, JSON.stringify(manifest, null, 2), 'utf-8');

  console.log(`âœ“ Graph realized`);
  console.log(`  Files: ${graph.nodes.length + 3} generated`);
  console.log(`  Manifest hash: ${manifestHash(manifest).slice(0, 8)}`);

  return { outDir, manifestPath };
}

/**
 * Generate package.json
 */
async function generatePackageJson(outDir: string, graph: GraphSpec): Promise<void> {
  const packageJson = {
    name: `candidate-${graph.id}`,
    version: graph.version,
    type: 'module',
    main: 'src/index.ts',
    scripts: {
      test: 'echo "Tests not yet implemented" && exit 0',
      build: 'tsc',
    },
    dependencies: {
      'forge-core': 'workspace:*',
      'forge-exec': 'workspace:*',
    },
  };

  await writeFile(
    join(outDir, 'package.json'),
    JSON.stringify(packageJson, null, 2),
    'utf-8'
  );
}

/**
 * Generate source files for each node
 */
async function generateSourceFiles(outDir: string, graph: GraphSpec): Promise<void> {
  // Generate index.ts
  const indexContent = `/**
 * Candidate Agent: ${graph.id}
 * Generated by forge-proposer
 */

export * from './graph.js';
${graph.nodes.map(n => `export * from './nodes/${n.id}.js';`).join('\n')}
`;

  await writeFile(join(outDir, 'src', 'index.ts'), indexContent, 'utf-8');

  // Generate graph.ts
  const graphContent = `import type { GraphSpec } from 'forge-core';

export const graph: GraphSpec = ${JSON.stringify(graph, null, 2)};
`;

  await writeFile(join(outDir, 'src', 'graph.ts'), graphContent, 'utf-8');

  // Generate node files
  const nodesDir = join(outDir, 'src', 'nodes');
  await mkdir(nodesDir, { recursive: true });

  for (const node of graph.nodes) {
    const nodeContent = generateNodeCode(node);
    await writeFile(join(nodesDir, `${node.id}.ts`), nodeContent, 'utf-8');
  }
}

/**
 * Generate code for a single node
 */
function generateNodeCode(node: any): string {
  return `/**
 * Node: ${node.id}
 * Kind: ${node.kind}
 */

export async function execute${capitalize(node.id)}(input: any): Promise<any> {
  // TODO: Implement ${node.kind} node logic
  console.log('Executing ${node.id}');
  
  return {
    nodeId: '${node.id}',
    kind: '${node.kind}',
    input,
    output: 'Not yet implemented',
  };
}
`;
}

/**
 * Generate test files
 */
async function generateTests(outDir: string, graph: GraphSpec): Promise<void> {
  const testContent = `/**
 * Tests for candidate ${graph.id}
 */

import { graph } from '../src/graph.js';

describe('Graph ${graph.id}', () => {
  it('should have correct structure', () => {
    expect(graph.id).toBe('${graph.id}');
    expect(graph.nodes).toHaveLength(${graph.nodes.length});
    expect(graph.edges).toHaveLength(${graph.edges.length});
  });

  it('should have no cycles', () => {
    // TODO: Implement cycle detection test
  });
${graph.nodes.map(n => `
  it('should execute node ${n.id}', async () => {
    // TODO: Implement node test
  });`).join('')}
});
`;

  await writeFile(join(outDir, 'tests', 'graph.test.ts'), testContent, 'utf-8');
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}